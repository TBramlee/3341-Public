package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MINUS, LPAREN, RPAREN, TIMES, NEGATE, RETURN, SEMICOLON,
         LCURLY, RCURLY, INT, IDENT, NIL, ASSIGN, PRINT, COMMA;

/* conditional terminals */
terminal EQUAL, GREATERTHANEQUAL, GREATERTHAN, LESSTHANEQUAL, LESSTHAN, 
         NOTEQUAL, NOT, AND, OR, IF, ELSE;
terminal Long    INTCONST;

non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal StmtList        stmtList; 
non terminal Stmt            stmt;
non terminal varDecl         varDecl;
non terminal formalDeclList  formalDeclList;
non terminal NeFormalDeclList    neFormalDeclList;
non terminal Cond            cond;

precedence left PLUS, MINUS;
precedence left TIMES;
precedence left NEGATE;


start with program;

program ::= INT IDENT LPAREN INT IDENT:arg RPAREN LCURLY stmtList:sl RCURLY
         {: RESULT = new Program(arg, sl, loc(argleft, argright)); :}
         |  varDecl LPAREN formalDeclList RPAREN LCURLY stmtList RCURLY
         ;

formalDeclList ::= neFormalDeclList
                | 
                ;

neFormalDeclList ::= varDecl COMMA neFormalDeclList
                  | varDecl
                  ;

stmtList ::= stmt:s stmtList:sl
             {: RESULT = new StmtList(s, sl, loc(sleft, sright)); :}
         |    /*string*/
             {: RESULT = null; :}
            
      ;

stmt ::= INT IDENT:id ASSIGN expr:e SEMICOLON
         {: RESULT = new DeclStmt(id, e, loc(idleft, idright)); :}
      |  IF LPAREN cond:c RPAREN stmt:s
         {: RESULT = new IfStmt(c, s, null, loc(cleft, cright)); :}
      |  IF LPAREN cond:c RPAREN stmt:s1 ELSE stmt:s2
         {: RESULT = new IfStmt(c, s1, s2, loc(cleft, cright)); :}
      |  PRINT expr:e SEMICOLON
         {:RESULT = new PrintStmt(e, loc(eleft, eright)); :}
      |  RETURN expr:e SEMICOLON
         {:RESULT = new ReturnStmt(e, loc(eleft, eright)); :}
      |  LCURLY stmtList:sl RCURLY
         {:RESULT = sl; :}
      ;

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      |  IDENT

      |  MINUS expr:e
         {: RESULT = new UnaryMinusExpr(e, loc(eleft, eright)); :}
         %prec NEGATE
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 TIMES expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e1right)); :}
            ;

cond ::= expr:e1 LESSTHANEQUAL expr:e2
         {: RESULT = new CondExpr(e1, CondExpr LESSTHANEQUAL, e2, loc(e1left, e1right)); :}

      |  expr:e1 GREATERTHANEQUAL expr:e2
         {: RESULT = new CondExpr(e1, CondExpr.GREATERTHANEQUAL, e2, loc(e1left, e1right)); :}

      |  expr:e1 EQUAL expr:e2
         {: RESULT = new CondExpr(e1, CondExpr.EQUAL, e2, loc(e1left, e1right)); :}

      |  expr:e1 NOTEQUAL expr:e2
         {: RESULT = new CondExpr(e1, CondExpr.NOTEQUAL, e2, loc(e1left, e1right)); :}

      |  expr:e1 LESSTHAN expr:e2
         {: RESULT = new CondExpr(e1, CondExpr.LESSTHAN, e2, loc(e1left, e1right)); :}

      |  expr:e1 GREATERTHAN expr:e2
         {: RESULT = new CondExpr(e1, CondExpr.GREATERTHAN, e2, loc(e1left, e1right)); :}

      |  cond:c1 AND cond:c2
         {: RESULT = new BinaryCond(c1, BinaryCond.AND, c2, loc(c1left, c1right)); :}
      
      |  cond:c1 OR cond:c2
         {: RESULT = new BinaryCond(c1, BinaryCond.OR, c2, loc(c1left, c1right)); :}

      |  NOT cond
         {: RESULT = new CondExpr(e1, CondExpr.NOT, e2, loc(e1left, e1right)); :}
      ;
